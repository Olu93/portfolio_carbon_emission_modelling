digraph "classes" {
rankdir=BT
charset="utf-8"
"abc.ABC" [color="grey", fontcolor="black", label="{abc.ABC|\l|}", shape="record", style="filled"];
"base.common.OxariEvaluator" [color="aliceblue", fontcolor="black", label="{base.common.OxariEvaluator|name\l|evaluate(y_true, y_pred)\l}", shape="record", style="filled"];
"base.common.OxariLogger" [color="aliceblue", fontcolor="black", label="{base.common.OxariLogger|\l|}", shape="record", style="filled"];
"base.common.OxariMixin" [color="aliceblue", fontcolor="black", label="{base.common.OxariMixin|end_time : NoneType\lobject_filename : str\lstart_time : NoneType\l|evaluate(y_true, y_pred)\loptimize(X_train, y_train, X_val, y_val)\lset_evaluator(evaluator: OxariEvaluator): 'OxariMixin'\lset_logger(logger: OxariLogger): 'OxariMixin'\lset_optimizer(optimizer: OxariOptimizer): 'OxariMixin'\l}", shape="record", style="filled"];
"base.common.OxariOptimizer" [color="aliceblue", fontcolor="black", label="{base.common.OxariOptimizer|num_startup_trials : int\lnum_trials : int\lsampler : TPESampler\l|optimize(X_train, y_train, X_val, y_val): Tuple[dict, Any]\lscore_trial(trial: optuna.Trial, X_train, y_train, X_val, y_val): Number\l}", shape="record", style="filled"];
"base.dataset_loader.CategoricalLoader" [color="aliceblue", fontcolor="black", label="{base.dataset_loader.CategoricalLoader|columns\l|}", shape="record", style="filled"];
"base.dataset_loader.DatasourceMixin" [color="aliceblue", fontcolor="black", label="{base.dataset_loader.DatasourceMixin|\l|}", shape="record", style="filled"];
"base.dataset_loader.FinancialLoader" [color="aliceblue", fontcolor="black", label="{base.dataset_loader.FinancialLoader|columns\l|}", shape="record", style="filled"];
"base.dataset_loader.LocalDatasourceMixin" [color="aliceblue", fontcolor="black", label="{base.dataset_loader.LocalDatasourceMixin|path\l|}", shape="record", style="filled"];
"base.dataset_loader.OxariDataManager" [color="aliceblue", fontcolor="black", label="{base.dataset_loader.OxariDataManager|IMPUTED : str\lORIGINAL : str\lcategorical_loader : Optional[CategoricalLoader]\ldata\lfinancial_loader : Optional[FinancialLoader]\lother_loaders : Optional[Dict[str, PartialLoader]]\lscope_loader : Optional[ScopeLoader]\lthreshold\lverbose : bool\l|add_data(name: str, df: pd.DataFrame, descr: str): 'OxariDataManager'\lget_data_by_index(index: int): pd.DataFrame\lget_data_by_name(name: str): pd.DataFrame\lget_scopes(name: str)\lrun(): 'OxariDataManager'\ltrain_test_val_split(X, y, split_size_test, split_size_val)\l}", shape="record", style="filled"];
"base.dataset_loader.PartialLoader" [color="aliceblue", fontcolor="black", label="{base.dataset_loader.PartialLoader|columns : Optional[List[str]]\ldata\lverbose : bool\l|run(): 'PartialLoader'\l}", shape="record", style="filled"];
"base.dataset_loader.ScopeLoader" [color="aliceblue", fontcolor="black", label="{base.dataset_loader.ScopeLoader|columns\lthreshold : int\l|}", shape="record", style="filled"];
"pandas.core.accessor.DirNamesMixin" [color="antiquewhite", fontcolor="black", label="{pandas.core.accessor.DirNamesMixin|\l|}", shape="record", style="filled"];
"pandas.core.arraylike.OpsMixin" [color="antiquewhite", fontcolor="black", label="{pandas.core.arraylike.OpsMixin|\l|}", shape="record", style="filled"];
"pandas.core.base.PandasObject" [color="antiquewhite", fontcolor="black", label="{pandas.core.base.PandasObject|\l|}", shape="record", style="filled"];
"pandas.core.frame.DataFrame" [color="antiquewhite", fontcolor="black", label="{pandas.core.frame.DataFrame|T\lagg\laxes\lboxplot\lcolumns : Index\lcolumns : Index\lhist\lindex : Index\lindex : MultiIndex, Index, RangeIndex\lname\lplot : CachedAccessor\lshape\lsparse : CachedAccessor\lstyle\lvalues\l|aggregate(func, axis: Axis)\lalign(other, join: str, axis: Axis | None, level: Level | None, copy: bool, fill_value, method: str | None, limit, fill_axis: Axis, broadcast_axis: Axis | None): DataFrame\lappend(other, ignore_index: bool, verify_integrity: bool, sort: bool): DataFrame\lapply(func: AggFuncType, axis: Axis, raw: bool, result_type, args)\lapplymap(func: PythonFuncType, na_action: str | None): DataFrame\lasfreq(freq: Frequency, method, how: str | None, normalize: bool, fill_value): DataFrame\lassign(): DataFrame\lbfill(axis: None | Axis, inplace: bool, limit: None | int, downcast): DataFrame | None\lclip(lower, upper, axis: Axis | None, inplace: bool): DataFrame | None\lcombine(other: DataFrame, func, fill_value, overwrite: bool): DataFrame\lcombine_first(other: DataFrame): DataFrame\lcompare(other: DataFrame, align_axis: Axis, keep_shape: bool, keep_equal: bool): DataFrame\lcorr(method: str | Callable[[np.ndarray, np.ndarray], float], min_periods: int): DataFrame\lcorrwith(other, axis: Axis, drop, method): Series\lcount(axis: Axis, level: Level | None, numeric_only: bool)\lcov(min_periods: int | None, ddof: int | None): DataFrame\ldiff(periods: int, axis: Axis): DataFrame\ldot(other: Series): Series\ldrop(labels, axis: Axis, index, columns, level: Level | None, inplace: bool, errors: str)\ldrop_duplicates(subset: Hashable | Sequence[Hashable] | None, keep: Literal['first'] | Literal['last'] | Literal[False], inplace: bool, ignore_index: bool): DataFrame | None\ldropna(axis: Axis, how: str, thresh, subset: IndexLabel, inplace: bool)\lduplicated(subset: Hashable | Sequence[Hashable] | None, keep: Literal['first'] | Literal['last'] | Literal[False]): Series\leval(expr: str, inplace: bool)\lexplode(column: IndexLabel, ignore_index: bool): DataFrame\lffill(axis: None | Axis, inplace: bool, limit: None | int, downcast): DataFrame | None\lfillna(value, method: FillnaOptions | None, axis: Axis | None, inplace: Literal[False], limit, downcast): DataFrame\lfrom_dict(data, orient: str, dtype: Dtype | None, columns): DataFrame\lfrom_records(data, index, exclude, columns, coerce_float: bool, nrows: int | None): DataFrame\lgroupby(by, axis: Axis, level: Level | None, as_index: bool, sort: bool, group_keys: bool, squeeze: bool | lib.NoDefault, observed: bool, dropna: bool): DataFrameGroupBy\lidxmax(axis: Axis, skipna: bool): Series\lidxmin(axis: Axis, skipna: bool): Series\linfo(verbose: bool | None, buf: WriteBuffer[str] | None, max_cols: int | None, memory_usage: bool | str | None, show_counts: bool | None, null_counts: bool | None): None\linsert(loc: int, column: Hashable, value: Scalar | AnyArrayLike, allow_duplicates: bool): None\linterpolate(method: str, axis: Axis, limit: int | None, inplace: bool, limit_direction: str | None, limit_area: str | None, downcast: str | None): DataFrame | None\lisin(values): DataFrame\lisna(): DataFrame\lisnull(): DataFrame\litems(): Iterable[tuple[Hashable, Series]]\literitems(): Iterable[tuple[Hashable, Series]]\literrows(): Iterable[tuple[Hashable, Series]]\litertuples(index: bool, name: str | None): Iterable[tuple[Any, ...]]\ljoin(other: DataFrame | Series, on: IndexLabel | None, how: str, lsuffix: str, rsuffix: str, sort: bool): DataFrame\llookup(row_labels: Sequence[IndexLabel], col_labels: Sequence[IndexLabel]): np.ndarray\lmask(cond, other, inplace, axis, level, errors, try_cast)\lmelt(id_vars, value_vars, var_name, value_name, col_level: Level | None, ignore_index: bool): DataFrame\lmemory_usage(index: bool, deep: bool): Series\lmerge(right: DataFrame | Series, how: str, on: IndexLabel | None, left_on: IndexLabel | None, right_on: IndexLabel | None, left_index: bool, right_index: bool, sort: bool, suffixes: Suffixes, copy: bool, indicator: bool, validate: str | None): DataFrame\lmode(axis: Axis, numeric_only: bool, dropna: bool): DataFrame\lnlargest(n: int, columns: IndexLabel, keep: str): DataFrame\lnotna(): DataFrame\lnotnull(): DataFrame\lnsmallest(n: int, columns: IndexLabel, keep: str): DataFrame\lnunique(axis: Axis, dropna: bool): Series\lpivot(index, columns, values): DataFrame\lpivot_table(values, index, columns, aggfunc, fill_value, margins, dropna, margins_name, observed, sort): DataFrame\lpop(item: Hashable): Series\lquantile(q, axis: Axis, numeric_only: bool, interpolation: str)\lquery(expr: str, inplace: bool)\lreindex(): DataFrame\lrename(mapper: Renamer | None): DataFrame | None\lreorder_levels(order: Sequence[Axis], axis: Axis): DataFrame\lreplace(to_replace, value, inplace: bool, limit, regex: bool, method: str | lib.NoDefault)\lresample(rule, axis, closed: str | None, label: str | None, convention: str, kind: str | None, loffset, base: int | None, on, level, origin: str | TimestampConvertibleTypes, offset: TimedeltaConvertibleTypes | None): Resampler\lreset_index(level: Hashable | Sequence[Hashable] | None, drop: bool, inplace: Literal[False], col_level: Hashable, col_fill: Hashable): DataFrame\lround(decimals: int | dict[IndexLabel, int] | Series): DataFrame\lselect_dtypes(include, exclude): DataFrame\lset_axis(labels, axis: Axis, inplace: Literal[False]): DataFrame\lset_index(keys, drop: bool, append: bool, inplace: bool, verify_integrity: bool)\lshift(periods, freq: Frequency | None, axis: Axis, fill_value): DataFrame\lsort_index(axis: Axis, level: Level | None, ascending: bool | int | Sequence[bool | int], inplace: bool, kind: str, na_position: str, sort_remaining: bool, ignore_index: bool, key: IndexKeyFunc)\lsort_values(by, axis: Axis, ascending, inplace: bool, kind: str, na_position: str, ignore_index: bool, key: ValueKeyFunc)\lstack(level: Level, dropna: bool)\lswaplevel(i: Axis, j: Axis, axis: Axis): DataFrame\lto_dict(orient: str, into)\lto_feather(path: FilePath | WriteBuffer[bytes]): None\lto_gbq(destination_table: str, project_id: str | None, chunksize: int | None, reauth: bool, if_exists: str, auth_local_webserver: bool, table_schema: list[dict[str, str]] | None, location: str | None, progress_bar: bool, credentials): None\lto_html(buf: FilePath | WriteBuffer[str] | None, columns: Sequence[str] | None, col_space: ColspaceArgType | None, header: bool | Sequence[str], index: bool, na_rep: str, formatters: FormattersType | None, float_format: FloatFormatType | None, sparsify: bool | None, index_names: bool, justify: str | None, max_rows: int | None, max_cols: int | None, show_dimensions: bool | str, decimal: str, bold_rows: bool, classes: str | list | tuple | None, escape: bool, notebook: bool, border: int | None, table_id: str | None, render_links: bool, encoding: str | None)\lto_markdown(buf: IO[str] | str | None, mode: str, index: bool, storage_options: StorageOptions): str | None\lto_numpy(dtype: npt.DTypeLike | None, copy: bool, na_value): np.ndarray\lto_parquet(path: FilePath | WriteBuffer[bytes] | None, engine: str, compression: str | None, index: bool | None, partition_cols: list[str] | None, storage_options: StorageOptions): bytes | None\lto_period(freq: Frequency | None, axis: Axis, copy: bool): DataFrame\lto_records(index, column_dtypes, index_dtypes): np.recarray\lto_stata(path: FilePath | WriteBuffer[bytes], convert_dates: dict[Hashable, str] | None, write_index: bool, byteorder: str | None, time_stamp: datetime.datetime | None, data_label: str | None, variable_labels: dict[Hashable, str] | None, version: int | None, convert_strl: Sequence[Hashable] | None, compression: CompressionOptions, storage_options: StorageOptions): None\lto_string(buf: None, columns: Sequence[str] | None, col_space: int | list[int] | dict[Hashable, int] | None, header: bool | Sequence[str], index: bool, na_rep: str, formatters: fmt.FormattersType | None, float_format: fmt.FloatFormatType | None, sparsify: bool | None, index_names: bool, justify: str | None, max_rows: int | None, max_cols: int | None, show_dimensions: bool, decimal: str, line_width: int | None, min_rows: int | None, max_colwidth: int | None, encoding: str | None): str\lto_timestamp(freq: Frequency | None, how: str, axis: Axis, copy: bool): DataFrame\lto_xml(path_or_buffer: FilePath | WriteBuffer[bytes] | WriteBuffer[str] | None, index: bool, root_name: str | None, row_name: str | None, na_rep: str | None, attr_cols: list[str] | None, elem_cols: list[str] | None, namespaces: dict[str | None, str] | None, prefix: str | None, encoding: str, xml_declaration: bool | None, pretty_print: bool | None, parser: str | None, stylesheet: FilePath | ReadBuffer[str] | ReadBuffer[bytes] | None, compression: CompressionOptions, storage_options: StorageOptions): str | None\ltransform(func: AggFuncType, axis: Axis): DataFrame\ltranspose(): DataFrame\lunstack(level: Level, fill_value)\lupdate(other, join: str, overwrite: bool, filter_func, errors: str): None\lvalue_counts(subset: Sequence[Hashable] | None, normalize: bool, sort: bool, ascending: bool, dropna: bool)\lwhere(cond, other, inplace, axis, level, errors, try_cast)\l}", shape="record", style="filled"];
"pandas.core.generic.NDFrame" [color="antiquewhite", fontcolor="black", label="{pandas.core.generic.NDFrame|attrs\laxes\lbackfill\ldtypes\lempty\lflags\lindex : RangeIndex\lkurtosis\lndim\lpad\lproduct\lshape\lsize\lvalues\l|abs(): NDFrameT\ladd_prefix(prefix: str): NDFrameT\ladd_suffix(suffix: str): NDFrameT\lalign(other, join, axis, level, copy, fill_value, method, limit, fill_axis, broadcast_axis)\lall(axis: Axis, bool_only: bool_t | None, skipna: bool_t, level: Level | None): Series | bool_t\lany(axis: Axis, bool_only: bool_t | None, skipna: bool_t, level: Level | None): Series | bool_t\lasfreq(freq, method, how: str | None, normalize: bool_t, fill_value): NDFrameT\lasof(where, subset)\lastype(dtype, copy: bool_t, errors: str): NDFrameT\lat_time(time, asof: bool_t, axis): NDFrameT\lbetween_time(start_time, end_time, include_start: bool_t | lib.NoDefault, include_end: bool_t | lib.NoDefault, inclusive: str | None, axis): NDFrameT\lbfill(axis: None | Axis, inplace: bool_t, limit: None | int, downcast): NDFrameT | None\lbool()\lclip(lower, upper, axis: Axis | None, inplace: bool_t): NDFrameT | None\lcompare(other, align_axis: Axis, keep_shape: bool_t, keep_equal: bool_t)\lconvert_dtypes(infer_objects: bool_t, convert_string: bool_t, convert_integer: bool_t, convert_boolean: bool_t, convert_floating: bool_t): NDFrameT\lcopy(deep: bool_t): NDFrameT\lcummax(axis: Axis | None, skipna: bool_t)\lcummin(axis: Axis | None, skipna: bool_t)\lcumprod(axis: Axis | None, skipna: bool_t)\lcumsum(axis: Axis | None, skipna: bool_t)\ldescribe(percentiles, include, exclude, datetime_is_numeric): NDFrameT\ldrop(labels, axis, index, columns, level, inplace: bool_t, errors: str)\ldroplevel(level, axis): NDFrameT\lequals(other: object): bool_t\lewm(com: float | None, span: float | None, halflife: float | TimedeltaConvertibleTypes | None, alpha: float | None, min_periods: int | None, adjust: bool_t, ignore_na: bool_t, axis: Axis, times: str | np.ndarray | DataFrame | Series | None, method: str): ExponentialMovingWindow\lexpanding(min_periods: int, center: bool_t | None, axis: Axis, method: str): Expanding\lffill(axis: None | Axis, inplace: bool_t, limit: None | int, downcast): NDFrameT | None\lfillna(value, method, axis, inplace: bool_t, limit, downcast): NDFrameT | None\lfilter(items, like: str | None, regex: str | None, axis): NDFrameT\lfirst(offset): NDFrameT\lfirst_valid_index(): Hashable | None\lget(key, default)\lhead(n: int): NDFrameT\linfer_objects(): NDFrameT\linterpolate(method: str, axis: Axis, limit: int | None, inplace: bool_t, limit_direction: str | None, limit_area: str | None, downcast: str | None): NDFrameT | None\lisna(): NDFrameT\lisnull(): NDFrameT\litems()\literitems()\lkeys()\lkurt(axis: Axis | None | lib.NoDefault, skipna: bool_t, level: Level | None, numeric_only: bool_t | None): Series | float\llast(offset): NDFrameT\llast_valid_index(): Hashable | None\lmad(axis: Axis | None, skipna: bool_t, level: Level | None): Series | float\lmask(cond, other, inplace, axis, level, errors, try_cast)\lmax(axis: Axis | None | lib.NoDefault, skipna: bool_t, level: Level | None, numeric_only: bool_t | None)\lmean(axis: Axis | None | lib.NoDefault, skipna: bool_t, level: Level | None, numeric_only: bool_t | None): Series | float\lmedian(axis: Axis | None | lib.NoDefault, skipna: bool_t, level: Level | None, numeric_only: bool_t | None): Series | float\lmin(axis: Axis | None | lib.NoDefault, skipna: bool_t, level: Level | None, numeric_only: bool_t | None)\lnotna(): NDFrameT\lnotnull(): NDFrameT\lpct_change(periods, fill_method, limit, freq): NDFrameT\lpipe(func: Callable[..., T] | tuple[Callable[..., T], str]): T\lpop(item: Hashable): Series | Any\lprod(axis: Axis | None, skipna: bool_t, level: Level | None, numeric_only: bool_t | None, min_count: int)\lrank(axis, method: str, numeric_only: bool_t | None | lib.NoDefault, na_option: str, ascending: bool_t, pct: bool_t): NDFrameT\lreindex(): NDFrameT\lreindex_like(other, method: str | None, copy: bool_t, limit, tolerance): NDFrameT\lrename_axis(mapper)\lreplace(to_replace, value, inplace: bool_t, limit: int | None, regex, method)\lresample(rule, axis, closed: str | None, label: str | None, convention: str, kind: str | None, loffset, base: int | None, on, level, origin: str | TimestampConvertibleTypes, offset: TimedeltaConvertibleTypes | None): Resampler\lrolling(window: int | timedelta | BaseOffset | BaseIndexer, min_periods: int | None, center: bool_t, win_type: str | None, on: str | None, axis: Axis, closed: str | None, method: str)\lsample(n: int | None, frac: float | None, replace: bool_t, weights, random_state: RandomState | None, axis: Axis | None, ignore_index: bool_t): NDFrameT\lsem(axis: Axis | None, skipna: bool_t, level: Level | None, ddof: int, numeric_only: bool_t | None): Series | float\lset_axis(labels, axis: Axis, inplace: Literal[False]): NDFrameT\lset_flags(): NDFrameT\lshift(periods, freq, axis, fill_value): NDFrameT\lskew(axis: Axis | None | lib.NoDefault, skipna: bool_t, level: Level | None, numeric_only: bool_t | None): Series | float\lslice_shift(periods: int, axis): NDFrameT\lsort_index(axis, level, ascending: bool_t | int | Sequence[bool_t | int], inplace: bool_t, kind: str, na_position: str, sort_remaining: bool_t, ignore_index: bool_t, key: IndexKeyFunc)\lsort_values(axis, ascending, inplace: bool_t, kind: str, na_position: str, ignore_index: bool_t, key: ValueKeyFunc)\lsqueeze(axis)\lstd(axis: Axis | None, skipna: bool_t, level: Level | None, ddof: int, numeric_only: bool_t | None): Series | float\lsum(axis: Axis | None, skipna: bool_t, level: Level | None, numeric_only: bool_t | None, min_count)\lswapaxes(axis1, axis2, copy): NDFrameT\ltail(n: int): NDFrameT\ltake(indices, axis, is_copy: bool_t | None): NDFrameT\lto_clipboard(excel: bool_t, sep: str | None): None\lto_csv(path_or_buf: FilePath | WriteBuffer[bytes] | WriteBuffer[str] | None, sep: str, na_rep: str, float_format: str | None, columns: Sequence[Hashable] | None, header: bool_t | list[str], index: bool_t, index_label: IndexLabel | None, mode: str, encoding: str | None, compression: CompressionOptions, quoting: int | None, quotechar: str, line_terminator: str | None, chunksize: int | None, date_format: str | None, doublequote: bool_t, escapechar: str | None, decimal: str, errors: str, storage_options: StorageOptions): str | None\lto_excel(excel_writer, sheet_name: str, na_rep: str, float_format: str | None, columns, header, index, index_label, startrow, startcol, engine, merge_cells, encoding, inf_rep, verbose, freeze_panes, storage_options: StorageOptions): None\lto_hdf(path_or_buf, key: str, mode: str, complevel: int | None, complib: str | None, append: bool_t, format: str | None, index: bool_t, min_itemsize: int | dict[str, int] | None, nan_rep, dropna: bool_t | None, data_columns: Literal[True] | list[str] | None, errors: str, encoding: str): None\lto_json(path_or_buf: FilePath | WriteBuffer[bytes] | WriteBuffer[str] | None, orient: str | None, date_format: str | None, double_precision: int, force_ascii: bool_t, date_unit: str, default_handler: Callable[[Any], JSONSerializable] | None, lines: bool_t, compression: CompressionOptions, index: bool_t, indent: int | None, storage_options: StorageOptions): str | None\lto_latex(buf, columns, col_space, header, index, na_rep, formatters, float_format, sparsify, index_names, bold_rows, column_format, longtable, escape, encoding, decimal, multicolumn, multicolumn_format, multirow, caption, label, position)\lto_pickle(path, compression: CompressionOptions, protocol: int, storage_options: StorageOptions): None\lto_sql(name: str, con, schema, if_exists: str, index: bool_t, index_label, chunksize, dtype: DtypeArg | None, method): int | None\lto_xarray()\ltruncate(before, after, axis, copy: bool_t): NDFrameT\ltshift(periods: int, freq, axis: Axis): NDFrameT\ltz_convert(tz, axis, level, copy: bool_t): NDFrameT\ltz_localize(tz, axis, level, copy: bool_t, ambiguous, nonexistent: str): NDFrameT\lvar(axis: Axis | None, skipna: bool_t, level: Level | None, ddof: int, numeric_only: bool_t | None): Series | float\lwhere(cond, other, inplace, axis, level, errors, try_cast)\lxs(key, axis, level, drop_level: bool_t)\l}", shape="record", style="filled"];
"pandas.core.indexing.IndexingMixin" [color="antiquewhite", fontcolor="black", label="{pandas.core.indexing.IndexingMixin|at\liat\liloc\lloc\l|}", shape="record", style="filled"];
"pathlib.Path" [color="grey", fontcolor="black", label="{pathlib.Path|\l|absolute()\lchmod(mode)\lcwd()\lexists()\lexpanduser()\lglob(pattern)\lgroup()\lhome()\lis_block_device()\lis_char_device()\lis_dir()\lis_fifo()\lis_file()\lis_mount()\lis_socket()\lis_symlink()\literdir()\llchmod(mode)\llink_to(target)\llstat()\lmkdir(mode, parents, exist_ok)\lopen(mode, buffering, encoding, errors, newline)\lowner()\lread_bytes()\lread_text(encoding, errors)\lreadlink()\lrename(target)\lreplace(target)\lresolve(strict)\lrglob(pattern)\lrmdir()\lsamefile(other_path)\lstat()\lsymlink_to(target, target_is_directory)\ltouch(mode, exist_ok)\lunlink(missing_ok)\lwrite_bytes(data)\lwrite_text(data, encoding, errors)\l}", shape="record", style="filled"];
"pathlib.PurePath" [color="grey", fontcolor="black", label="{pathlib.PurePath|anchor\ldrive : property\lname\lparent\lparents\lparts\lroot : property\lstem\lsuffix\lsuffixes\l|as_posix()\las_uri()\lis_absolute()\lis_relative_to()\lis_reserved()\ljoinpath()\lmatch(path_pattern)\lrelative_to()\lwith_name(name)\lwith_stem(stem)\lwith_suffix(suffix)\l}", shape="record", style="filled"];
"base.common.OxariEvaluator" -> "abc.ABC" [arrowhead="empty", arrowtail="none"];
"base.common.OxariMixin" -> "abc.ABC" [arrowhead="empty", arrowtail="none"];
"base.common.OxariOptimizer" -> "abc.ABC" [arrowhead="empty", arrowtail="none"];
"base.dataset_loader.CategoricalLoader" -> "abc.ABC" [arrowhead="empty", arrowtail="none"];
"base.dataset_loader.CategoricalLoader" -> "base.dataset_loader.PartialLoader" [arrowhead="empty", arrowtail="none"];
"base.dataset_loader.DatasourceMixin" -> "abc.ABC" [arrowhead="empty", arrowtail="none"];
"base.dataset_loader.FinancialLoader" -> "abc.ABC" [arrowhead="empty", arrowtail="none"];
"base.dataset_loader.FinancialLoader" -> "base.dataset_loader.PartialLoader" [arrowhead="empty", arrowtail="none"];
"base.dataset_loader.LocalDatasourceMixin" -> "base.dataset_loader.DatasourceMixin" [arrowhead="empty", arrowtail="none"];
"base.dataset_loader.OxariDataManager" -> "base.common.OxariMixin" [arrowhead="empty", arrowtail="none"];
"base.dataset_loader.PartialLoader" -> "abc.ABC" [arrowhead="empty", arrowtail="none"];
"base.dataset_loader.ScopeLoader" -> "abc.ABC" [arrowhead="empty", arrowtail="none"];
"base.dataset_loader.ScopeLoader" -> "base.dataset_loader.PartialLoader" [arrowhead="empty", arrowtail="none"];
"pandas.core.base.PandasObject" -> "pandas.core.accessor.DirNamesMixin" [arrowhead="empty", arrowtail="none"];
"pandas.core.frame.DataFrame" -> "pandas.core.arraylike.OpsMixin" [arrowhead="empty", arrowtail="none"];
"pandas.core.frame.DataFrame" -> "pandas.core.generic.NDFrame" [arrowhead="empty", arrowtail="none"];
"pandas.core.generic.NDFrame" -> "pandas.core.base.PandasObject" [arrowhead="empty", arrowtail="none"];
"pandas.core.generic.NDFrame" -> "pandas.core.indexing.IndexingMixin" [arrowhead="empty", arrowtail="none"];
"pathlib.Path" -> "pathlib.PurePath" [arrowhead="empty", arrowtail="none"];
"base.common.OxariEvaluator" -> "base.common.OxariMixin" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_evaluator", style="solid"];
"base.common.OxariLogger" -> "base.common.OxariMixin" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_logger", style="solid"];
"base.common.OxariOptimizer" -> "base.common.OxariMixin" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_optimizer", style="solid"];
"pandas.core.frame.DataFrame" -> "base.dataset_loader.OxariDataManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_df_original", style="solid"];
"pandas.core.frame.DataFrame" -> "base.dataset_loader.OxariDataManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_df_preprocessed", style="solid"];
"pandas.core.frame.DataFrame" -> "base.dataset_loader.OxariDataManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_df_filled", style="solid"];
"pandas.core.frame.DataFrame" -> "base.dataset_loader.OxariDataManager" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="_df_estimated", style="solid"];
"pandas.core.frame.DataFrame" -> "base.dataset_loader.PartialLoader" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="data", style="solid"];
"pandas.core.frame.DataFrame" -> "pandas.core.frame.DataFrame" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="index", style="solid"];
"pathlib.Path" -> "base.dataset_loader.LocalDatasourceMixin" [arrowhead="diamond", arrowtail="none", fontcolor="green", label="path", style="solid"];
}
